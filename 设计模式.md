# 设计模式

##  1.面向对象

**1.面向对象的三大特性**

封装,继承,多态

**2.接口**

定义:若干抽象方法的集合

作用:限制实现接口的类,必须按照接口给定的调用方式实现这些方法,对高层模块隐藏了类的内部实现

**3.面向对象的设计solid原则**

| 名称         | 定义                                                         |
| :----------- | ------------------------------------------------------------ |
| 开放封闭原则 | 软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 |
| 里式替换原则 | 所有引用父类的地方必须能透明地使用其子类对象                 |
| 依赖倒置原则 | 高层模块不应该依赖低层模块,二者后应该依赖其抽象(抽象不应该依赖细节,细节应该依赖抽象(接口) 换而言之,要针对接口编程而不是针对实现编程) |
| 接口隔离原则 | 使用多个专门的接口,而不是单一的总接口,即客户端不应该依赖那些它不需要的接口 |
| 单一职责原则 | 不要存在多于一个类变更的原因,通俗的说,既一个类只负责一项职责(就一个类而言，应该仅有一个引起它变化的原因。应该只有一个职责) |

## 2.创建型模式

### 1.工厂模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 |
| **应用场景** | 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 <br>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。<br>3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。 |
| **角色**     | 抽象工厂角色(creator),<br>具体工厂角色(concrete creator)<br>抽象产品角色(product)<br>具体产品角色(concrete product) <br>客户端(client) |
| **优点**     | 1、一个调用者想创建一个对象，只要知道其名称就可以了。<br> 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。<br> 3、屏蔽产品的具体实现，调用者只关心产品的接口 |
| **缺点**     | 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事 |



###  2.抽象工厂模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 |
| **应用场景** | 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。     |
| **角色**     | 抽象工厂角色(creator)<br>具体工厂角色(concrete creator)<br>多个抽象产品角色(product)<br>具体产品角色(concrete product) <br>客户端(client) |
| **优点**     | 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象 |
| **缺点**     | 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码 |

### 3.建造者模型

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 使用多个简单的对象一步一步构建成一个复杂的对象               |
| **应用场景** | 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐 |
| **角色**     | 抽象建造者(Builder)<br>具体建造者(Concrete Builder)<br>指挥者(Director)<br>产品(product) <br> |
| **优点**     | 1.隐藏了一个产品的内部结构和装配过程<br/>2.将构造代码与表示代码分开<br>3.可以对构造过程进行更精细的控制<br>**注意**建造者模式与抽象工厂模式相似,也是用来创建复杂对象,主要是建造者模式着重一步一步构造复杂的对象,而抽象工厂模式着重于多个系列的产品对象 |
| **缺点**     | 1、产品必须有共同点，范围有限制。<br/> 2、如内部变化复杂，会有很多的建造类。 |

### 4.单例模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 一个类只能被单个对象创建                                     |
| **应用场景** | 1.要求生产唯一序列号<br> 2.WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来<br>3.创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 |
| **角色**     | 单例基类,需要实现单例类                                      |
| **优点**     | 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）<br>2.避免对资源的多重占用（比如写文件操作）。 |
| **缺点**     | 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 |



## 3.结构型模式

### 1.适配器模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 |
| **应用场景** | 1.JAVA 中的 jdbc<br/>2在linux上运行windows程序<br/>          |
| **角色**     | **目标接口**(Target),<br>**待适配的类**(Adaptee),<br>**适配器**(Adapter):**类适配器:**使用多继承,**对象适配器:**使用组合 |
| **优点**     | 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 |
| **缺点**     | 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构 |



### 2.桥模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 将抽象部分与实现部分解耦，使它们都可以独立的变化             |
| **角色**     | **抽象**(Abstraction):**Shape**<br>**细化抽象**(RefnedAbstraction) :长方形,圆形<br/>**实现者**(implementor):**Color**<br/>**具体实现者**(ConcreImplementor):红色,蓝色 |
| **优点**     | 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。 |
| **缺点**     | 桥接模式的引入会增加系统的理解与设计难度，由于**聚合关联关系**建立在抽象层，要求开发者针对抽象进行设计与编程 |
| **应用场景** | 1,如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系<br> 2,对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用<br> 3,一个类存在两个独立变化的维度，且这两个维度都需要进行扩展 |

### 3.组合模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性 |
| **角色**     | **抽象组件**(Component):**Graphic**<br>**叶子组件**(Leaf) :**Point**<br/>**复核组件**(Composite):**Line,Picture**<br/>**客户端**(Client) |
| **优点**     | 1.定义了包含基本对象和组合对象的类层次结构<br/>2.简化客户端代码,即客户端可以一致地使用组合对象和单个对象<br/>3.更容易增加新的类型 |
| **缺点**     | 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则 |
| **应用场景** | 部分、整体场景，如<br>1.点,线,面<br>2.树形菜单，文件、文件夹的管理 |

### 4.外观模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 |
| **角色**     | **外观**(facade):****<br>**子系统类**(subsystem class) :****<br/> |
| **优点**     | 1.减少系统相互依赖,子系统相对独立<br/> 2、提高灵活性。<br/> 3、提高了安全性,为复杂的模块或子系统提供外界访问的模块,预防低水平人员带来的风险<br/> |
| **缺点**     | 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。       |
| **应用场景** | 1,去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。<br> 2,JAVA 的三层开发模式 |



### 5.代理模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 为对象提供一种代理以控制这种对象                             |
| **角色**     | 抽象实体(Subject)<br>实体(RealSubject)<br>代理(Proxy)        |
| **优点**     | **远程代理:**可以隐藏对象位于远程地址空间的事实<br/>**虚代理 :** 可以进行优化,例如根据需求创建对象<br/>**保护代理:**允许在访问一个对象的时候有一些附加的内务处理<br> |
| **缺点**     | 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<br/> 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂 |
| **应用场景** | 按职责来划分，通常有以下使用场景：<br> 1、远程代理。<br> 2、虚拟代理。<br> 3、Copy-on-Write 代理。<br/>4、保护（Protect or Access）代理。<br/> 5、Cache代理。<br/> 6、防火墙（Firewall）代理。<br/> 7、同步化（Synchronization）代理。<br/> 8、智能引用（Smart Reference）代理 |



## 4.行为型模式

### 1.责任链模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 |
| **角色**     | **抽象处理者**(Handler)<br>**具体处理者:**(ConcreteHandler)<br/>**客户端:**(Client) |
| **优点**     | 1、降低耦合度。它将请求的发送者和接收者解耦。<br> 2、简化了对象。使得对象不需要知道链的结构。<br> 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。<br> 4、增加新的请求处理类很方便 |
| **缺点**     | 1、不能保证请求一定被接收。<br> 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。<br>3、可能不容易观察运行时的特征，有碍于除错 |
| **应用场景** | 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。<br> 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。<br> 3、可动态指定一组对象处理请求 |

### 2.观察者模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 定义对象间的一种**一对多**的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 |
| **角色**     | **抽象发布者:**(Subject)<br>**具体发布者:**(ConcreteSubject)<br/>**抽象观察者:**(Obeserver)<br>**具体观察者:**(ConcerteObserver) |
| **优点**     | 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。      |
| **缺点**     | 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。<br> 2、如果在观察者和观察目标之间**有循环依赖**的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。<br> 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化 |
| **应用场景** | 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。<br> 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。<br> 一个对象必须通知其他对象，而并不知道这些对象是谁 |

### 3.策略者模式

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 一个类的行为或其算法可以在运行时更改                         |
| **角色**     | **抽象策略:**(Strategy)<br>**具体策略:**(ConcreteStrategy)<br/>**上下文:**(Context)<br> |
| **优点**     | 1、算法可以自由切换。<br/> 2、避免使用多重条件判断。<br/> 3、扩展性良好。 |
| **缺点**     | 1、策略类会增多。<br/> 2、所有策略类都需要对外暴露。<br>**注意事项：**如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 |
| **应用场景** | 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br> 2、一个系统需要动态地在几种算法中选择一种。<br> 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现 |

### 4.模板方法

| 1            | 2                                                            |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 |
| **角色**     | **抽象类:**(AbstractClass) 定义抽象的原子操作(钩子操作),实现一个模板方法作为算法的骨架<br>**具体类:**(ConcreteClass) 实现原子操作<br/> |
| **优点**     | 1、封装不变部分，扩展可变部分。<br/> 2、提取公共代码，便于维护。<br/> 3、行为由父类控制，子类实现 |
| **缺点**     | 1.每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大 |
| **应用场景** | 1、有多个子类共有的方法，且逻辑相同。<br/> 2、重要的、复杂的方法，可以考虑作为模板方法<br/> |







